# 851复习文档

> ### By Liuxiao && Minus

## 线性结构

​	*什么是线性结构，链表和线性表的区别，二者的特点*

#### 线性结构的概念

>  线性结构是一种数据元素之间存在一对一关系的数据结构。在这种结构中，除了第一个和最后一个元素外，每个元素都有一个直接前驱和一个直接后继。线性结构可以是顺序存储的（如数组），也可以是非顺序存储的（如链表）
>
>  ***\*线性表（Linear List）\**** 通常指的是逻辑上的概念，它是一个由n个数据元素组成的有限序列。这些数据元素具有相同的类型，并且有先后次序。如数组。
>
>  ***\*链表（Linked List）\**** 是一种物理存储单元上非连续、非顺序的线性结构，用一组任意的存储单元来存放线性表中的数据元素。链表中的数据元素被称为节点，每个节点包含数据域和指向下一个节点的指针域。根据指针的连接方式，链表可以分为单链表、双链表和循环链表等。
>
>  ***\*二者的特点：\****
>
>  线性表（以数组为例）
>
>  o 随机访问：可以直接通过下标在O(1)时间内访问到指定位置的元素。
>
>  o 存储密度高：由于元素在内存中是连续存储的，所以没有额外的空间浪费。
>
>  o 插入删除效率低：如果需要在中间插入或删除元素，则可能需要移动大量元素，平均时间复杂度为O(n)。
>
>  o 固定大小：一般而言，数组创建时需要指定大小，在使用过程中不容易改变。
>
>  链表
>
>  o 顺序访问：只能从头节点开始，逐个访问后续节点，无法直接跳转到某个特定位置，访问时间为O(n)。
>
>  o 插入删除效率高：只需要修改前后节点的指针即可完成插入或删除操作，不需要移动元素，时间复杂度为O(1)。
>
>  o 存储密度较低：因为每个节点除了数据域外还需要额外的指针域来链接下一个节点
>
>  

#### 结构体定义&&操作

##### 顺序表

```c++
#include <iostream>
using namespace std;

const int N = 100010;

typedef struct SqList
{
    int data[N];
    int length;
} SqList;

void InitList(SqList &L) 
{
    for (int i = 0; i < MaxSize; i++)
        L.data[i] = 0;//将所有数据元素设置为默认初始值
    L.length = 0;//顺序表初始长度为0
 }

int InsertElem(SqList &L, int index, int x)  // 顺序表， 插入位置， 插入元素
{
    if (index < 0 || index > L.length || L.length == MaxSize) // 首先判断位置以及剩余空间是否合理
        return 0;//插入位置不正确， 或长度已经达到最大
    //从最后一个元素到index,依次向后移动一个
    for (int i = L.length - 1; i >= index; i--) {
        L.data[i + 1] = L.data[i];
    }
    L.data[index] = x; //插入元素
    L.length++; //长度+1
    return 1;
 }

int DeleteElem(SqList &L, int index)
{
    if (index < 0 || index >= L.length)
    {
        cout << "INDEX OR LENGTH ERROR " << endl;
        return 0;
    }
    int tmp = L.data[index];
    for (int i = index; i < L.length - 1; i ++ )  // 0~n-2
        L.data[i] = L.data[i + 1]; // 循环前移
    L.length --;
    return tmp; // 返回一下删除的数
}

int getElem_Index(SqList L, int index)
{
    if (index < 0 || index >= L.length)
    {
        cout << "INDEX ERROR" << endl;
        return 0;
    }
    return L.data[index];
}

int getElem_Value(SqList L, int e)
{
    for (int i = 0; i < L.length; i ++ )
        if (L.data[i] == e)
            return i;
    return -1; // 查找失败
}

int main() 
{
    SqList L;//声明一个顺序表SqList
    InitList(L);//初始化顺序表
    return 0;
}
```

单链表

```c++
#include <iostream>
using namespace std;

typedef struct LNode
{
	int data;
	struct LNode *next;
} LNode, *LinkList;

void LinkList_Initial(LinkList &L)
{
    if (L != NULL) 
    {
    	cout << "Alreay Initial" << endl;
        return;
    }
    L = (LNode*)malloc(sizeof(LNode));
    if (L == NULL)
    {
        cout << "MALLOC ERROR" << endl;
       	return;
    }
    L->next = NULL;
}

void LinkList_Insert_byOrder(LinkList &L)
```

双链表

```c++
typedef struct DLNode
{
	int data;
    struct DLNode *prior, *next;
} DLNode, *DLinkList;
```

循环链表  // 与单链表一致， 只不过将尾指针指向头结点		

## 树、二叉树、 森林

### 树

> 树（Tree） 是一种非线性的数据结构，它由n（n>=0）个有限节点组成一个具有层次关系的集合。这个集合满足以下条件：
>
> 1. 有一个特定的称为根（root）的节点。
> 2. 剩余的节点可以被分为m（m >= 0）个互不相交的子集T1, T2, ..., Tm，每个子集本身又是一棵树，并且这些子集被称为根的子树。
> 3. 在树结构中，除了根节点之外，每个节点有且仅有一个父节点，而根节点没有父节点。同时，一个节点可以有零个或多个子节点。

### 二叉树

> **二叉树（**Binary Tree） 是一种特殊的树结构，它的特点是每个节点最多只能有两个子节点：左子节点和右子节点。即使某节点只有一个子节点，也要区分是左子节点还是右子节点。二叉树的定义如下：
>
> 二叉树可以为空。如果非空，则该树由根节点、左子树和右子树组成，其中左子树和右子树也是二叉树。
>
> 二叉树的一些重要特性包括：
>
>  每个节点至多只有两个子节点。
>
> 左子树和右子树是有顺序的，不能随意交换。
>
> 即使树中某个节点只有一棵子树，也要区分它是左子树还是右子树。

#### 二叉树结构

``` c
using namespace std;
typedef struct BiTNode{
   int data;
   struct  BiTNode *left,*right;
}&BiTree;
```

#### 非递归先序(Pre)

``` c
using namespace std;
typedef struct BiTNode{
   int data;
   struct  BiTNode *left,*right;
}&BiTree;

void PreOrder(BiTree t) {
    stack<BiTNode *> s;
    BiTNode *p = t;
    while (p or !s.empty()) {
        //p不空 或者栈不空
        if (p) {
            printf(" %d--", p->data);
            s.push(p);
            p = p->left;//访问左边先 跟左右
        } else {
            p = s.top();//空 弹出上一个 去访问它的右孩子
            s.pop();
            p = p->right;
        }
    }
}

```

#### 非递归中序(In)

``` c
using namespace std;
typedef struct BiTNode{
   int data;
   struct  BiTNode *left,*right;
}&BiTree;

void InOrder(BiTree t) {
    stack<BiTNode *> s;
    BiTNode *p = t;
    while (p or !s.empty()) {
        //p不空 或者栈不空
        if (p) {
            s.push(p); //先入栈不访问
            p = p->left;//一路向左找

        } else {//某个父节点的左孩子为空 返回父结点并访问
            p = s.top();//空 弹出上一个 去访问它的右孩子
            s.pop();
            printf("%d--", p->data);//这里和先序不太一样
            p = p->right;
        }
    }
}

```

#### 非递归后序(Post)

``` c
using namespace std;
typedef struct BiTNode{
   int data;
   struct  BiTNode *left,*right;
}&BiTree;


void postOrder(BiTree t) {
    stack<BiTNode *> s;
    BiTNode *visited = NULL;//记录最近访问过的结点
    BiTNode *p = t;
    while (p or !s.empty()) {
        while (p) {
            //尽可能往左走
            s.push(p);
            p = p->left;
        }
        //左边到头了 查看栈元素
        p = s.top();
        if (p->right == NULL or p->right == visited) {
            cout << "--" << p->data;//没右孩子 或 右边已经访问过了
            s.pop();//已经访问该结点
            visited = p;//更新最新结点
            p = NULL;//设置为NULL  以便下一次迭代可以处理栈中的下一个结点
            //比如最后一个结点是根节点 你访问了肯定要设为空 不然is.empty一直为true
        } else {
            //去遍历右子树先
            p = p->right;
        }
    }
}
```

### 平衡二叉树(BST)

>平衡二叉树是一种特殊的二叉树，它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都必须是平衡二叉树。这种结构确保了树的高度保持在对数级别（以2为底），从而保证了各种操作（如查找、插入和删除）的时间复杂度都是O(log n)，其中n是节点的数量。

### 森林

>  森林（Forest） 是指零个或多个不相交的树的集合。换句话说，如果将一棵树的根节点移除，那么剩下的部分就变成了一个森林。森林中的每棵树都是独立的，没有任何节点共享相同的父节点。森林可以看作是树的一种扩展形式，二叉树是对树的一种限制，而森林则是多棵树的集合。
>
> 

```c++
#include <bits/stdc++.h>

using namespace std;

int main(){
    
   
}
```

## 图

### 邻接矩阵



``` c
const int Maxn = 1e3 + 7;
// 邻接矩阵定义
typedef struct MGraph {
char vexes[Maxn]; // 顶点表，可以不要
int edges[Maxn][Maxn]; // 用邻接矩阵存储边
int vexNum, arcNum; // 顶点数，边数
} MGraph;
```

### 邻接表

``` c
const int Maxn = 1e3 + 7;
//边结点
struct ArcNode {
int adjvex; //顶点编号
ArcNode *next; //指向vi的下一个邻接顶点
};
// 顶点结点
struct VNode {
int data; //顶点信息
ArcNode *firstarc; //指向vi的第一个邻接顶点（边）
};
// 图的邻接表表示
typedef struct AGraph {
VNode adjlist[Maxn]; // 顺序存储所有顶点链表的表头结点
int vexNum, arcNum; // 图的顶点个数，边数
} AGraph;
```

### 深搜(DFS)

> 设初始状态时图中的所有顶点未被访问，则： 
>
> 1. 首先，访问开始结点从起始结点开始任选一个相邻并未被 访问的结点，访问； 
> 2. 接着，把找到的结点作为起始结点继续访问其相邻且未被 访问的一个结点； 
> 3. 重复2的操作直到某一个结点所有相邻结点都被访问，则 退回最近被访问且还有相邻结点未被访问的结点；  
> 4. 把3中结点作为起始结点继续执行2，3操作直到所有结点 都被访问完为止

#### dfs邻接表

``` 	c

int visited[100] = {0};//标记是否访问数组
void visit(int x) {
    cout << x << endl;
}
void dfs(AGraph *g, int v) {
    //访问开始结点
    visited[v] = 1;
    visit(v);
    ArcNode *p = g->adjlist[v].firstarc;//v指向的第一个邻接结点
       while (p != NULL) {//从起始结点开始任选一个相邻并为访问的结点
        if (visited[p->adjvex] != 1) {
            dfs(g,p->adjvex);//把找到的边 作为起始顶点继续访问
            //为访问过 深度优先
        }
        p = p->next;
    }
}
void dfsTraverse(AGraph *g) {
    for (int i = 0; i < g->vexNum; ++i) {
        if (visited == 0)  //不需要 重置0 因为 可能有点 不连通 需要继续dfs
            dfs(g, i);
    }//遍历每个没被访问的结点 从他开始进行dfs遍历 每调用一次，将遍历一个连通分量
}

```

#### dfs邻接矩阵

``` 	c
int visited[100] = {0};//标记是否访问数组
void visit(int x) {
    cout << x << endl;
}
void dfs(MGraph *g, int v) {
    //访问开始结点
    visited[v] = 1;
    visit(v);
    for (int i = 0; i < g->vexNum; ++i) {
        if (g->edges[v][i] == 1 and !visited[i])//有路径且未访问过
            dfs(g, i);
    }
}

void dfsTraverse(MGraph *g) {
    for (int i = 0; i < g->vexNum; ++i) {
         if (visited[i] == 0)
            dfs(g, i);
    }//遍历每个没被访问的结点 从他开始进行dfs遍历 每调用一次，将遍历一个连通分量
}
```





## 排序

>  ==*堆排序*==（Heap Sort）是一种基于比较的排序算法，它利用了堆这种数据结构所设计的一种选择排序。堆是一种特殊的完全二叉树，其中每个父节点的值都大于或等于（最大堆）其所有子节点的值，或者每个父节点的值都小于或等于（最小堆）其所有子节点的值。
>
>  ==堆排序的三个时间复杂度都是O(longn),空间复杂度O(1)==
>
>  在堆排序中，我们通常使用最大堆来对数组进行升序排序。以下是堆排序的基本思想和步骤：
>
>  ### 堆排序的思想
>
>  - 首先将待排序序列构建成一个最大堆。
>  - 然后将堆顶元素（即最大值）与序列末尾的元素交换，使得最大值位于已排序部分的末尾。
>  - 重新调整剩余的序列成为一个新的最大堆。
>  - 重复上述过程，直到整个序列排序完成。
>
>  ### 堆排序的步骤
>
>  1. **构建初始堆**：从最后一个非叶子节点开始，向下调整以确保满足最大堆性质。这个过程称为“堆化”
>    - 对于一个大小为 n 的数组，最后一个非叶子节点的位置是 (n/2) - 1。
>    - 从这个位置开始，向前遍历每一个非叶子节点，并调用堆化函数来维护最大堆属性。
>  2. **交换堆顶元素与末尾元素**：将当前堆顶元素（最大值）与未排序序列的最后一个元素交换，然后缩小未排序序列的范围。
>  3. **调整堆**：对于新调整后的堆，再次执行堆化操作，使剩下的元素重新构成最大堆。
>  4. **重复步骤2和3**：持续上述过程，每次都将当前的最大值移动到已排序部分的末尾，直至整个数组变为有序。
>
>  

### 堆排序

``` c++
//
// Created by nvjiachengba on 20/9/2024.
//
#include <bits/stdc++.h>
using namespace std;
// 调整为大根堆 以k为根节点的子树  数组下标从1开始
void HeapAdjust(int arr[], int k, int n) {
    int i = 2 * k;//左孩子
    while (i <= n) {
        //一层一层向下筛选
        if (i < n and arr[i] < arr[i + 1]) {
            i++;//i指向较大的子节点 沿着值大的子节点往下筛选
        }

        if (arr[k] < arr[i]) {
            //根节点比两个孩子中较大的孩子小 交换
            swap(arr[k], arr[i]);
            k = i;//继续调整受影响的子树
            i = k * 2;
        } else {
            break;//无影响 调整结束
        }
    }
}

// 构建大根堆
void buildMaxHeap(int arr[], int n) {
    // 从最后一个非叶子节点开始调整
    for (int i = n / 2; i >= 0; i--)//从后往前调整 例如7个元素 1-2-3 非叶节点是1，2，3下标
        HeapAdjust(arr, n, i);
}

// 堆排序
void heapSort(int arr[], int n) {
    // 构建大根堆
    buildMaxHeap(arr, n);
    // 逐个移除堆顶元素 与待排序序列中的最后一个元素进行交换
    for (int i = n; i > 1; i--) {
        // 将堆顶元素移到数组末尾
        //为什么移动到末尾 因为如果你 这相当于排序 你要给他移动到 n n-1 n-2····1
        swap(arr[1], arr[i]);
        // 调整剩余元素为大根堆
        HeapAdjust(arr, 1, i - 1);
    }
}

// 打印数组
void printArray(int arr[], int n) {
    for (int i = 0; i < n; ++i)
        printf("%d ", arr[i]);
    printf("\n");
}

int main() {
    int arr[] = {12, 11, 13, 5, 6, 7};
    int n = 6;
    printf("Original array: \n");
    printArray(arr, n);
    heapSort(arr, n);
    printf("Sorted array: \n");
    printArray(arr, n);
    return 0;
}
```



# 算法



## 递归

### 定义思想

> 1. 直接或间接地调用自身的算法称为递归算法。用函数自身给出定义的函数称为递归函数。 
> 2. 直接递归：p函数中调用p函数 
> 3. 间接递归：p函数调用q函数，q函数又调用p函数。 
> 4. 递归函数的两个要素：边界条件、递归方程

> ### 递归小结： 
>
> 1.优点：结构清晰，可读性强，而且容易用数学归纳法来证明算法的正确性，因此它为设计算法、调试程序 带来很大方便。 
>
> 2.缺点：递归算法的运行效率较低，无论是耗费的计算时间还是占用的存储空间都比非递归算法要多。 
>
> 3.解决方法：在递归算法中消除递归调用，使其转化为非递归算法。采用一个用户定义的栈来模拟系统的递归调用工作栈。该方法通用性强，但本质上还是递归 优化效果不明显。 （2）、用递推来实现递归函数。 （3）、通过变换能将一些递归转化为尾递归，从而迭代求出结果

### 分治与递归的区别

> **分治法与递归区别**： 
>
> 1. 分治法是解决问题的方法。
>
> 2. 递归是实现各种算法的工具，二叉树、回溯、贪心算法等都可以选择用递归的方式来解决。

## 分治

### 定义思想

> **定义：** 分治法是一种将问题分解成若干个规模较小的相同子问题，然后递归地解决这些子问题，并将各个子问题的解合并得到原问题解的方法。
>
> **思想：**
>
> 1. **分解**：将原问题分解为几个规模较小、相互独立且与原问题形式相同的子问题。
> 2. **解决**：若子问题规模足够小，则直接求解；否则继续分解为更小的子问题，直到可以直接求解。
> 3. **合并**：将子问题的解逐层合并，形成最终的原问题的解

## 动规

### 定义思想

> **定义**：
> 动态规划是通过把原问题分解为相对简单的子问题来求解复杂问题的一种方法。它通常用来解决最优化问题，即从许多可行解中找出一个最优解。
>
> **思想**：
>
> 重叠子问题：动态规划适用于子问题会重复出现的情况，这样可以通过保存已经解决过的子问题的答案来避免重复计算。
> 最优子结构：一个问题的最优解依赖于其子问题的最优解。这意味着可以通过组合子问题的最优解来构造整个问题的最优解。记忆化：利用数组或哈希表存储已解决子问题的结果，以减少计算量。

## 动规和分治联系与区别

> ### 相同点
>
> 1. **分解思想**：
>    - 两者都将原问题分解成较小的子问题。
>    - 都试图通过解决这些子问题来构建整个问题的解决方案。
> 2. **递归结构**：
>    - 分治法通常采用自顶向下的递归来解决问题。
>    - 动态规划也可以使用带有记忆化的递归来实现，这被称为自顶向下的方法。
>
> ### 不同点
>
> 1. **子问题的独立性**：
>    - 分治法中的子问题是独立的，不共享状态信息。
>    - 动态规划处理的是具有重叠子问题的情况，这些子问题之间可能存在依赖关系。
> 2. **求解方式**：
>    - 分治法通常是自顶向下的递归过程。
>    - 动态规划可以是自底向上的迭代过程，也可以采用带备忘录的自顶向下的递归方法。
> 3. **适用场景**：
>    - 分治法适合用于能够被分解为多个完全独立的子问题的问题。
>    - 动态规划适合于那些可以通过分解为更小的子问题并且子问题存在重叠的情况，以及需要寻找最优解的问题。

## 贪心

> **定义**： 贪心算法总是作出在当前看来最好的选择,即贪心选择。也就是说贪心算法并不从整体最优考虑， 
>
> 它所作出的选择只是在某种意义上的局部最优选择。 (当然，希望贪心算法得到的最终结果也是整体最优的。 虽然贪心算法不能对所有问题都得到整体最 优解， 但对许多问题它能产生整体最优解。 在一些情况下， 即使贪心算法不能得到整体最优解， 其最终结果却是最优解的很好近似。
>
> **基本要素**： 贪心选择性质：指所求问题的整体最优解可以通过一系列局部最优的选择， 即贪心选择来达到。（动规的每一步选择往往与其子问题的解有关，而贪心选择不顾前后，仅看当下。） 最优子结构性质：当一个问题的最优解包含其子问题的最优解时，称此问题具有最优子结构性质
>
> 贪心算法的特点： 
>
>  a.贪心算法并不保证得到最优解，但是，对于很多问题确实可以求得最优解。 
>
> b.贪心算法可能依赖之前作出的决定，但是，不依赖任何将来的选择或是子问题的解。 
>
> c.贪心算法适用于组合优化问题 
>
> d.贪心算法的求解过程是多步判断过程，最终的判断序列对应于问题的最优解。 
>
> e.依据**某种** “眼前最好，短视的” （这说明在具体的问题中，有多种不同的贪心策略，我们需 要进行可行性的判定）贪心选择性质判断，性质好坏决定算法的成败。 
>
> f. 贪心法必须进行正确性证明 
>
> g.证明贪心法的不正确的技巧： 举反例



### 贪心和动规

> ### 贪心算法
>
> - **局部最优选择**：贪心算法在每一步都做出当前看起来最好的选择，并且期望这些局部最优的选择能够导致全局最优解。
> - **适用范围有限**：贪心算法只适用于那些具有“贪心选择性质”的问题。也就是说，局部最优解可以累积成为全局最优解的问题。对于很多问题，贪心算法可能无法找到最优解。
>
> ### 动态规划
>
> - **全局考虑**：动态规划通过将问题分解为子问题来寻找最优解，并利用子问题的解来构造原问题的解。它会考虑到所有可能的情况，从而确保得到全局最优解。
> - **记忆化/重叠子问题**：动态规划利用了子问题的重叠性质，即同一个子问题不会被重复计算多次。通常通过使用数组或其他数据结构存储已经解决过的子问题的结果。
> - **递归与迭代**：动态规划既可以采用自顶向下的递归方式，也可以采用自底向上的迭代方式。
>
> ### 相同点
>
>    都要求最优子结构
>
> ### 贪心算法的优缺点： 
>
>    优点：算法简单，时间和空间复杂度低。 
>
>   缺点：适用范围有限。



## 回溯

> **定义**： 在问题的解空间树中， 按深度优先策略，从根结点出发搜索解空间树。（问题的解空间一般用树形式来组织，也称为解空间树或状态空间） 
>
> **问题的解空间**: 一个复杂问题的解决方案是由若干个小的决策步骤组成的决策序列，解决一个问题的所有可能的决策序列 构成该问题的解空间。 
>
> 解空间树: 问题的解空间一般用树形式来组织，也称为解空间树或状态空间，树中的每一个结点确定所求解问题的一个问题状态。 
>
> 树的根结点位于第1层，表示搜索的初始状态（不做任何选择），第2层的结点做出第一次选择后到达的状 态，以此类推。 
>
> 可行解与最优解: 解空间中满足约束条件的决策序列称为可行解。 解任何问题都有一个目标，在约束条件下使目标达到最优的可行解称为该问题的最优解。
>
> 其他概念: 活结点： 是指自身已生成但其孩子结点没有全部生成的结点。 
>
> 扩展结点： 是指正在产生孩子结点的结点。 
>
> 死结点： 是指由根结点到该结点构成的部分解不满足约束条件，或者其子结点已经搜索完毕。 
>
> 子孙： 结点E的子树上所有结点都是E的子孙。 
>
> 祖宗： 从结点E到树根路径上的所有结点都是E的祖宗。

### 回溯思想 

> 1. **试探**：从根节点（通常是初始状态）开始，按照一定的顺序探索可能的解。
> 2. **前进**：在每一步中，根据问题定义做出一个选择，进入下一个状态。
> 3. **检查**：到达某个状态后，判断这个状态是否满足问题的部分约束条件。如果满足，则继续深入；如果不满足，则需要进行回溯。
> 4. **回溯**：当发现当前的选择不能导致有效的解时，算法会撤销之前的选择（即“回溯”），回到上一个决策点，尝试其他未被探索过的选项。
> 5. **终止条件**：当找到一个完整的解或者所有可能的解都被探索完毕时，算法结束

> **剪枝**：在回溯过程中，通过某些条件提前终止对不可能产生有效解的分支的探索，从而减少不必要的计算。这包括限界函数和约束函数。
>
> - ==**约束函数**==：用来决定哪些节点是可行的，即这些节点对应的解部分满足问题的约束条件。//可行解
> - ==**限界函数**==：用于估计子树中的最优解，以确定是否值得进一步探索该子树  //最优解

## 分支限界

> ### 定义
>
> 分支限界法（Branch and Bound, B&B）是一种用于求解优化问题的算法，结合了广度优先搜索和贪心算法的思想，通过系统地生成可行解，并利用限界函数来避免探索那些不可能产生最优解的分支，从而提高搜索效率。

### 思想

> ### 分支限界法的思想
>
> 1. **分支**：将问题分解为更小的子问题，每个子问题代表了解空间的一部分。
> 2. **限界**：对于每一个子问题，==计算一个下界（最小化问题）或上界（最大化问题）==，这个界限用来估计从当前节点开始能够得到的最好结果。
> 3. **剪枝**：如果某个节点的界限已经超过了目前已知的最佳解，则可以放弃对该节点及其后代节点的进一步探索，因为它们不会导致更好的解。
> 4. **选择**：按照一定的策略（如队列、堆等）选择下一个要扩展的节点，通常选择最有希望改进当前最佳解的节点。
> 5. **更新**：一旦找到一个新的可行解，就更新最佳解，并用新的最佳解去修剪更多的分支。

> ### 相关概念
>
> - **状态空间树**：类似于回溯法中的解空间树，分支限界法也构建了一个表示所有可能解的状态空间树。
> - **活节点**：在搜索过程中尚未被完全处理的节点，即还有可能成为最终解路径上的节点。
> - **死节点**：已经被确定不能产生比现有最优解更好的解的节点。
> - **限界函数**：提供了一个关于解质量的估计，用来决定是否需要继续探索某个分支。对于最小化问题，限界函数给出的是下界；对于最大化问题，限界函数给出的是上界。
> - **最优性剪枝**：当一个节点的限界值大于等于当前已知最优解时，该节点及其子节点就可以被剪掉。
> - **可行性剪枝**：当一个节点不满足问题的约束条件时，也可以进行剪枝。
> - **优先队列/堆**：用来存储待处理的活节点，并根据某种标准（通常是限界值）对这些节点进行排序，以确保总是优先处理最有可能改进当前最优解的节点。

> ### 两种分支限界法：
>
>  1.队列式(FIFO)分支限界法：按照队列先进先出（ FIFO） 原则选取下一个节点为扩展节点。 
>
>  2.优先队列式分支限界法：按照优先队列中规定的优先级选取优先级最高的节点成为当前扩展节点。

> ### 队列式分枝限界法组织结点表: 
>
> 1.将根结点加入活结点队列。 
>
> 2.从活结点队中取出队头结点，作为当前扩展结点。 
>
> 3.对当前扩展结点，先从左到右地产生它的所有孩子结点，用约束条件检查，把所有满足约束条件的孩子 结点加入活结点队列。 
>
> 4.重复步骤2和3，直到找到一个解或活结点队列为空为止

> ### **优先队列式分枝限界法组织结点表**: 
>
> 1.计算起始结点（根结点）的优先级并加入优先队列（与特定问题相关的信息的函数值决定优先级）。 
>
> 2.从优先队列中取出优先级最高的结点作为当前扩展结点，使搜索朝着解空间树上可能有最优解的分枝推 进，以便尽快地找出一个最优解。 
>
> 3.对当前扩展结点，先从左到右地产生它的所有孩子结点，然后用约束条件检查，对所有满足约束条件的 孩子结点计算优先级并加入优先队列。 
>
> 4.重复步骤2和3，直到找到一个解或优先队列为空为止

>### **回溯法与分支限界对比**: 
>
>相同：都需要搜索解空间求解 
>
>不同：1.回溯法按照深度优先搜索，分支限界按照广度优先 
>
>2.回溯法存储结点的数据结构是栈，而分支限界是队列、优先队列 
>
>3.回溯法结点多次成为活结点，分支限界每个结点只有一次成为活结点的机会

# 代码篇

## 阶乘

``` c
int fun(int n) {
    if (n == 0)
        return 1;
    return n * fun(n - 1);
}

int fun2(int n) {//非递归
    int sum = 1;

    if (n == 0) {
        return 1;
    } else {
        for (int i = 2; i <= n; ++i) {
            sum *= i;
        }
    }
    return sum;
}

```

## Fibonacci

``` c
    if (n == 1 or n == 2) {
        return 1;
    } else {
        return fib(n - 1) + fib(n - 2);
    }
}
```



## 二分查找

``` c
int BinarySearch(int arr[], int n, int x) {//记住 数组是有序的
     int left=0;
     int right=n-1;
    while (left <= right) {
        int mid = (left + right) / 2;
        if (x == arr[mid])
            return mid;
        if (x < arr[mid]) {
            right = mid - 1;
        } else {
            left = mid + 1;
        }
    }
    return -1;//**没找到
}
```

## 快排 (QuickSort)

> #### 思想
>
> 快速排序是一种分治算法，其基本思想是通过一趟排序将待排记录分割成独立的两部分，其中一部分记录的关键字均比另一部分记录的关键字小，然后分别对这两部分继续进行排序，以达到整个序列有序的目的。
>
> #### 步骤
>
> 1. **选择枢轴（Pivot）**：从数组中选择一个元素作为枢轴。
> 2. 分区（Partition）
>    - 将所有小于枢轴的元素移到枢轴的左边。
>    - 将所有大于枢轴的元素移到枢轴的右边。
> 3. 递归排序
>    - 对枢轴左边的子数组进行快速排序。
>    - 对枢轴右边的子数组进行快速排序。

``` c

int partition(int arr[], int low, int high) {
    //挖空法
    int pivot = arr[low];//选取第一个元素作为枢轴
    while (low < high) {
        while (low < high and arr[high] >= pivot)
            high--;
        arr[low] = arr[high];
        while (low < high and arr[low] <= pivot)
            low++;
        arr[high] = arr[low];
    }
    arr[low]=pivot;//基准元素最后的位置
    return low;//返回中间位置
}

void quickSort(int arr[],int low,int high){
    if (low<high){
        int pivot=partition(arr,low,high);
        quickSort(arr,low,pivot-1);
        quickSort(arr,pivot+1,high);
    }
}
```

## 归排

>#### 思想
>
>归并排序也是一种分治算法，其基本思想是将数组分成两个子数组，分别对这两个子数组进行排序，然后将排序好的子数组合并成一个有序数组。
>
>#### 步骤
>
>1. **分解**：将数组分成两个子数组。
>2. 递归排序
>   - 对左子数组进行归并排序。
>   - 对右子数组进行归并排序。
>3. **合并**：将两个有序的子数组合并成一个有序数组。

``` c
int temp[100];//临时 辅助数组
void Merge(int arr[], int left, int right) {//合并
    int mid = (left + right) / 2;//分左右
    int i = left;
    int j = mid + 1;
    int k = 0;
    while (i <= mid and j <= right) {
        if (arr[i] <= arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while (i <= mid)
        temp[k++] = arr[i++];
    while (j <= right)
        temp[k++] = arr[j++];
    k=0;
    for (int l = left; l <= right; ++l)
        arr[l] = temp[k++];
}
void MergeSort(int arr[], int left, int right) {//n=8 right=7
    if (left == right)
        return;
    int mid = (left + right) / 2;
    MergeSort(arr, left, mid);
    MergeSort(arr, mid + 1, right);
    Merge(arr, left,right);
}
```

## 棋盘覆盖

> ### 算法思想
>
> 1. **分治法**：
>    - 将棋盘分成四个 2n−1×2n−12*n*−1×2*n*−1 的子棋盘。
>    - 特殊方格必然位于这四个子棋盘中的一个。
>    - 对于不含特殊方格的子棋盘，选择一个“伪”特殊方格，使得每个子棋盘都有一个特殊方格。//自己添加 tile
> 2. **递归处理**：
>    - 递归地对每个子棋盘进行同样的操作，直到子棋盘大小为 1x1。
>    - 当子棋盘大小为 1x1 时，直接返回，因为 1x1 的棋盘无法再分割。
> 3. **放置 L 形瓦片**：
>    - 在每个子棋盘中，选择一个位置放置 L 形瓦片，以覆盖除了特殊方格之外的其他三个方格。
>    - 通过递归调用，确保每个子棋盘都被正确覆盖。
>
> ### 详细步骤
>
> 1. **初始化**：
>
>    - 定义一个全局变量 `tile` 用于标记不同的 L 形瓦片。
>    - 定义一个二维数组 `board` 用于存储棋盘的状态。
>
> 2. **递归函数 `ChessBoard`**：
>
>    - `tr` 和 `tc`：当前子棋盘的左上角行和列。
>    - `dr` 和 `dc`：特殊方格的行和列。
>    - `size`：当前子棋盘的大小。
>
>    - 递归终止条件：如果 `size` 为 1，则直接返回。
>    - 计算子棋盘的边长的一半 `s = size / 2`。
>    - 根据特殊方格的位置，递归处理四个子棋盘，并在需要的地方放置 L 形瓦片。

```  c
//https://www.bilibili.com/video/BV1QV411m7ff/?spm_id_from=333.337.search-card.all.click&vd_source=c2bfbb10b5c8153f1e5c3785b908c9b9
int tile = 1;
int board[100][100] = {0};

void ChessBoard(int tr, int tc, int dr, int dc, int size) {
    // 左上角的行 列， 特殊方块的行 列，棋盘的大小
    if (size == 1) {//1*1 的棋盘无法再分割
        return;
    }
    //2*n 2*3 6*6
    int t = tile++;//标号用的
    int s = size / 2;//取边长一般
    //覆盖左上角  1 1
    //          1 0
    if (dr < tr + s and dc < tc + s) {   //若特殊方格在棋盘中 左下角的右下角
        ChessBoard(tr, tc, dr, dc, s);
    } else {
        board[tr + s - 1][tc + s - 1] = t;//填上数 方便看
        ChessBoard(tr, tc, tr + s - 1, tc + s - 1, s);//不能填的位置 左上角的右下角-1
    }

    //覆盖右上角  1 1
    //          0 1
    if (dr < tr + s and dc >= tc + s) {   //若特殊方格在棋盘右上角中
        // < 和 >=都可以 要么加上 -1或+1边界问题而已
        ChessBoard(tr, tc + s, dr, dc, s);
    } else {
        board[tr + s - 1][tc + s] = t;//特殊的-1
        ChessBoard(tr, tc + s, tr + s - 1, tc + s, s);//右上角的左下角
    }

    //再左下角    1 0
    //          1 1
    if (dr >= tr + s and dc < tc + s) {   //若特殊方格在棋盘中
        ChessBoard(tr + s, tc, dr, dc, s);
    } else {
        board[tr + s][tc + s - 1] = t;
        ChessBoard(tr + s, tc, tr + s, tc + s - 1, s);
    }
    //覆盖右下角
    if (dr >= tr + s and dc >= tc + s) {   //若特殊方格在棋盘中
        ChessBoard(tr + s, tc + s, dr, dc, s);
    } else {
        board[tr + s][tc + s] = t;
        ChessBoard(tr + s, tc + s, tr + s, tc + s, s);
    }
}

int main() {
    int size = 8;
    ChessBoard(0, 0, 1, 1, size);
    for (int i = 0; i < size; ++i) {
        for (int j = 0; j < size; ++j) {
            cout << board[i][j] << "  ";
        }
        cout << endl;
    }
}
```

## 循环日程表

> **符合分治策略的思想**，将所有的选手分为两半，n个选手的比赛日程就可以通过分成n/2个选手设计的比赛日程表来决定。采用递归的方式对选手进行割分，直至割分到只剩下1位选手时，比赛日程表就不在需要为其排列。
>
> **边界条件：**n = 1
>
> **分解子问题：**
>
> 1.递归左上角赛程表
>
> 2.递归左下角赛程表
>
> 3.将左上角赛程表copy到右下角
>
> 4.将左下角赛程表copy到右上角

``` c
//循环日程表
void table(int arr[maxNum][maxNum], int y, int len) {
    if (len == 1) {
        arr[0][y] = y + 1;//第0行
        return;
    }
    table(arr, y, len / 2);//左上
    table(arr, y + len / 2, len / 2);//右上
//    上面分治会把 其余的值 赋好 下面等着复制就行
    for (int i = 0; i < len / 2; ++i) {
        for (int j = 0; j < len / 2; ++j) {
            arr[len / 2 + i][y + len / 2 + j] = arr[i][y + j];//左上到右下
            arr[len / 2 + i][y + j] = arr[i][y + len / 2 + j];//右上 复制到左下
        }
    }
}
```

